=== Phase 14: GHC Native Parallelism vs OpenMP ===

GHC Capabilities: 4
OpenMP threads:   4

--- sinsum: sequential Haskell vs parallel Haskell vs OpenMP ---

  Elements   | Seq Haskell  | Seq C        | Par Haskell  | Par OpenMP   | Hs/OMP  | C/OMP  
  -----------|--------------|--------------|--------------|--------------|---------|--------
       1000 |      25.3 us |      18.6 us |      30.5 us |      19.7 us |  1.54x  |  0.94x
       5000 |     154.2 us |      68.6 us |      63.4 us |      23.1 us |  2.75x  |  2.97x
      10000 |     327.0 us |     148.0 us |     107.3 us |      42.9 us |  2.50x  |  3.45x
      50000 |    1657.2 us |     756.2 us |     500.4 us |     194.5 us |  2.57x  |  3.89x
     100000 |    3283.6 us |    1549.8 us |     881.1 us |     375.8 us |  2.34x  |  4.12x
     500000 |   16249.7 us |    7383.7 us |    4147.5 us |    2982.5 us |  1.39x  |  2.48x
    1000000 |   31922.8 us |   15417.0 us |    8637.3 us |    6626.1 us |  1.30x  |  2.33x
    5000000 |  164669.3 us |   92499.1 us |   41042.2 us |   18724.0 us |  2.19x  |  4.94x
   10000000 |  336020.5 us |  153998.0 us |   85324.7 us |   40187.1 us |  2.12x  |  3.83x

--- Correctness verification ---
  Sequential Haskell: 137.9342990594
  Parallel Haskell:   137.9342990594 (diff = 5.1e-12)
  Sequential C:       137.9342990594 (diff = 0.0e0)
  Parallel OpenMP:    137.9342990594 (diff = 5.1e-12)

--- Analysis ---
  OpenMP (C) advantages:
    - Unboxed computation: no allocation, no GC pressure
    - GCC vectorization: SIMD for numeric loops
    - Cache-friendly: contiguous memory, no thunk indirection

  Haskell forkIO advantages:
    - No FFI boundary: works on Haskell data structures directly
    - Lightweight: thousands of green threads at low cost
    - Composable: integrates with STM, async, streaming

  Guideline: use OpenMP for unboxed numeric arrays,
  Haskell parallelism for functional transformations.

=== Done ===
