<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GHC's Runtime System as an OpenMP Runtime</title>
<style>
  :root {
    --bg: #ffffff;
    --fg: #1a1a1a;
    --accent: #2563eb;
    --accent-light: #dbeafe;
    --border: #e5e7eb;
    --code-bg: #f3f4f6;
    --table-head: #f9fafb;
    --success: #059669;
    --warn: #d97706;
    --mono: 'Menlo', 'Consolas', 'DejaVu Sans Mono', monospace;
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #111827;
      --fg: #e5e7eb;
      --accent: #60a5fa;
      --accent-light: #1e3a5f;
      --border: #374151;
      --code-bg: #1f2937;
      --table-head: #1f2937;
      --success: #34d399;
      --warn: #fbbf24;
    }
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html { font-size: 17px; scroll-behavior: smooth; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.7;
    color: var(--fg);
    background: var(--bg);
    max-width: 52rem;
    margin: 0 auto;
    padding: 2rem 1.5rem 6rem;
  }
  h1 { font-size: 2rem; margin: 2rem 0 0.5rem; letter-spacing: -0.02em; }
  h2 { font-size: 1.5rem; margin: 3rem 0 1rem; padding-bottom: 0.3rem; border-bottom: 2px solid var(--accent); }
  h3 { font-size: 1.15rem; margin: 2rem 0 0.75rem; }
  h4 { font-size: 1rem; margin: 1.5rem 0 0.5rem; }
  p { margin: 0 0 1rem; }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }
  .subtitle { color: #6b7280; font-size: 1.1rem; margin-bottom: 2rem; }
  .toc { background: var(--code-bg); border-radius: 8px; padding: 1.25rem 1.5rem; margin: 2rem 0; }
  .toc h3 { margin: 0 0 0.75rem; font-size: 1rem; }
  .toc ol { padding-left: 1.25rem; }
  .toc li { margin: 0.25rem 0; }
  code {
    font-family: var(--mono);
    font-size: 0.88em;
    background: var(--code-bg);
    padding: 0.15em 0.4em;
    border-radius: 4px;
  }
  pre {
    background: var(--code-bg);
    border-radius: 8px;
    padding: 1rem 1.25rem;
    overflow-x: auto;
    margin: 1rem 0 1.5rem;
    line-height: 1.5;
    font-size: 0.85rem;
  }
  pre code { background: none; padding: 0; }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0 1.5rem;
    font-size: 0.92rem;
  }
  th, td { padding: 0.5rem 0.75rem; border: 1px solid var(--border); text-align: left; }
  th { background: var(--table-head); font-weight: 600; }
  td.num { text-align: right; font-family: var(--mono); font-size: 0.85em; }
  .highlight { background: var(--accent-light); padding: 1rem 1.25rem; border-radius: 8px; border-left: 4px solid var(--accent); margin: 1.5rem 0; }
  .highlight p:last-child { margin-bottom: 0; }
  figure { margin: 1.5rem 0; }
  figcaption { font-size: 0.85rem; color: #6b7280; margin-top: 0.5rem; text-align: center; }
  .diagram {
    background: var(--code-bg);
    border-radius: 8px;
    padding: 1.25rem;
    font-family: var(--mono);
    font-size: 0.8rem;
    line-height: 1.4;
    overflow-x: auto;
    white-space: pre;
  }
  .badge {
    display: inline-block;
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.15em 0.5em;
    border-radius: 4px;
    vertical-align: middle;
  }
  .badge-ok { background: #d1fae5; color: #065f46; }
  .badge-fast { background: #dbeafe; color: #1e40af; }
  .badge-note { background: #fef3c7; color: #92400e; }
  @media (prefers-color-scheme: dark) {
    .badge-ok { background: #064e3b; color: #6ee7b7; }
    .badge-fast { background: #1e3a5f; color: #93c5fd; }
    .badge-note { background: #78350f; color: #fcd34d; }
  }
  ul, ol { margin: 0 0 1rem; padding-left: 1.5rem; }
  li { margin: 0.25rem 0; }
  .phase-label {
    display: inline-block;
    background: var(--accent);
    color: white;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 0.1em 0.6em;
    border-radius: 3px;
    margin-right: 0.3em;
    vertical-align: middle;
  }
  hr { border: none; border-top: 1px solid var(--border); margin: 3rem 0; }
  footer { margin-top: 4rem; padding-top: 1.5rem; border-top: 1px solid var(--border); color: #6b7280; font-size: 0.85rem; }
</style>
</head>
<body>

<h1>GHC's Runtime System as an OpenMP Runtime</h1>
<p class="subtitle">A feasibility study in replacing libgomp with GHC RTS Capabilities</p>

<nav class="toc">
<h3>Contents</h3>
<ol>
  <li><a href="#abstract">Abstract</a></li>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#background">Background</a></li>
  <li><a href="#architecture">Architecture</a></li>
  <li><a href="#implementation">Implementation</a></li>
  <li><a href="#optimization">Optimization: Achieving Parity</a></li>
  <li><a href="#haskell-interop">Haskell Interop</a></li>
  <li><a href="#gc-interaction">Garbage Collection Interaction</a></li>
  <li><a href="#bidirectional">Bidirectional Interop</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#bugs">Notable Bugs and Fixes</a></li>
  <li><a href="#limitations">Limitations</a></li>
  <li><a href="#conclusions">Conclusions</a></li>
  <li><a href="#appendix">Appendix: Implemented ABI Surface</a></li>
</ol>
</nav>

<!-- ================================================================ -->
<h2 id="abstract">1. Abstract</h2>

<p>We implement a drop-in OpenMP runtime library that uses GHC's Runtime System
as its threading infrastructure. Standard C code compiled with
<code>gcc -fopenmp</code> runs on GHC Capabilities instead of libgomp's
pthreads. The runtime implements the GCC <code>GOMP_*</code> ABI and the
<code>omp_*</code> user API, supporting parallel regions, worksharing loops,
barriers, critical sections, tasks, and sections.</p>

<p>After lock-free optimization, the runtime achieves <strong>performance parity
with native libgomp</strong> on both microbenchmarks and real numerical workloads
(dense matrix multiplication). Haskell programs call OpenMP-parallelized C code
via FFI, with both runtimes sharing the same thread pool. OpenMP workers
call back into Haskell via <code>FunPtr</code> with automatic Capability
acquisition. GHC's stop-the-world garbage collector does not pause OpenMP
workers because they do not hold Capabilities.</p>

<!-- ================================================================ -->
<h2 id="motivation">2. Motivation</h2>

<p>GHC's RTS has a mature, production-quality thread pool with per-Capability
run queues, work-stealing spark pools, NUMA awareness, and sophisticated
scheduling. OpenMP runtimes (libgomp, libomp) maintain their own, separate
thread pools. When a Haskell program calls OpenMP-annotated C code via FFI,
two independent thread pools compete for the same CPU cores.</p>

<p>If the OpenMP runtime used GHC's thread pool directly, we would get:</p>
<ul>
  <li><strong>Unified resource management</strong> &mdash; one thread pool, not two</li>
  <li><strong>Seamless interop</strong> &mdash; Haskell green threads and OpenMP parallel regions coexist naturally</li>
  <li><strong>GHC as a platform</strong> &mdash; C programs benefit from GHC's scheduler, and Haskell programs get access to OpenMP's parallel-for without reinventing it</li>
</ul>

<p>This project investigates whether this is feasible and what the performance
cost is.</p>

<!-- ================================================================ -->
<h2 id="background">3. Background</h2>

<h3>3.1 GHC RTS Capabilities</h3>

<p>A <em>Capability</em> is GHC's central execution unit: one OS thread, one
run queue of lightweight Haskell threads (TSOs), and one work-stealing spark
pool. The number of Capabilities is set by <code>+RTS -N</code>. Each
Capability has a 0-indexed number (<code>cap->no</code>) that maps directly to
OpenMP's <code>omp_get_thread_num()</code>.</p>

<p>Key RTS APIs for embedding:</p>
<pre><code>hs_init_ghc(&amp;argc, &amp;argv, conf);       // Boot the RTS
Capability *cap = rts_lock();           // Acquire a Capability
rts_unlock(cap);                        // Release it
rts_setInCallCapability(i, 1);          // Pin OS thread to Capability i
uint32_t getNumCapabilities(void);      // Current Capability count
uint32_t getNumberOfProcessors(void);   // CPU count</code></pre>

<p><code>hs_init_ghc()</code> is reference-counted: calling it when the RTS is
already running (as in a Haskell host program) simply increments the counter
and returns. This is the key to transparent interop &mdash; our runtime
auto-detects whether it is being hosted by a C program or a Haskell program.</p>

<h3>3.2 The libgomp ABI</h3>

<p>GCC transforms OpenMP pragmas into calls to <code>GOMP_*</code> functions.
For example:</p>

<pre><code>#pragma omp parallel
{ body; }

// becomes:
void outlined_fn(void *data) { body; }
GOMP_parallel(outlined_fn, &amp;data, num_threads, flags);</code></pre>

<p>A minimum viable runtime needs only 9 symbols (<code>GOMP_parallel</code>,
<code>GOMP_barrier</code>, <code>GOMP_critical_start/end</code>,
<code>GOMP_single_start</code>, <code>GOMP_task</code>,
<code>GOMP_taskwait</code>, <code>omp_get_num_threads</code>,
<code>omp_get_thread_num</code>). Full OpenMP 4.5 coverage requires ~85
symbols. Our implementation provides ~75.</p>

<!-- ================================================================ -->
<h2 id="architecture">4. Architecture</h2>

<figure>
<div class="diagram">
Haskell program                    C program
(ghc -threaded)                    (gcc -fopenmp -no-hs-main)
       |                                  |
       | foreign import ccall safe        | calls GOMP_parallel()
       v                                  v
  +---------------------------------------------------------+
  |           ghc_omp_runtime_rts.c                         |
  |                                                         |
  |  GOMP_parallel(fn, data, N, flags):                     |
  |    1. ensure_rts()  -- boot GHC RTS if needed           |
  |    2. Store fn/data, bump atomic generation counter     |
  |    3. Wake workers (condvar broadcast)                  |
  |    4. Start barrier -- all threads sync                 |
  |    5. fn(data) on all threads                           |
  |    6. End barrier -- all threads sync                   |
  |    7. Wait for worker completion                        |
  +---------------------------------------------------------+
       |
       v
  +---------------------------------------------------------+
  |              GHC Runtime System                         |
  |                                                         |
  |  +--------+  +--------+  +--------+  +--------+        |
  |  | Cap 0  |  | Cap 1  |  | Cap 2  |  | Cap 3  |        |
  |  | master |  | worker |  | worker |  | worker |        |
  |  +--------+  +--------+  +--------+  +--------+        |
  |                                                         |
  |  Workers are OS threads pinned to Capabilities.         |
  |  After rts_lock()/rts_unlock() init, they do NOT        |
  |  hold Capabilities -- invisible to GC.                  |
  +---------------------------------------------------------+</div>
<figcaption>Figure 1: Runtime architecture. Workers are plain OS threads registered with
GHC's RTS but not holding Capabilities during OpenMP execution.</figcaption>
</figure>

<h3>4.1 Worker Pool Design</h3>

<p>N-1 worker threads are created at initialization. Each is pinned to a GHC
Capability via <code>rts_setInCallCapability(i, 1)</code>, performs one
<code>rts_lock()/rts_unlock()</code> cycle to register with the RTS, then enters
a spin-wait loop on an atomic generation counter.</p>

<p>The master thread (Capability 0) dispatches work by:</p>
<ol>
  <li>Storing the function pointer and data</li>
  <li>Atomically incrementing the generation counter (release fence)</li>
  <li>Broadcasting a condvar (for sleeping workers)</li>
  <li>Participating in the start barrier, executing <code>fn(data)</code>, and hitting the end barrier</li>
</ol>

<h3>4.2 Synchronization Primitives</h3>

<p>All barriers use a <strong>sense-reversing centralized barrier</strong>:
each thread maintains a local sense flag. Threads atomically decrement a shared
counter; the last thread flips the global sense, releasing all waiters. This is
fully lock-free on the fast path.</p>

<p>Workers use a <strong>spin-then-sleep</strong> strategy: spin for ~4000
iterations on the generation counter (using <code>_mm_pause</code>), then fall
back to a <code>pthread_cond_wait</code> for power efficiency during idle
periods.</p>

<!-- ================================================================ -->
<h2 id="implementation">5. Implementation Phases</h2>

<h3><span class="phase-label">Phase 1</span> Stub Runtime (pthread-based)</h3>
<p>A shared library (<code>libghcomp.so</code>) implementing the GOMP ABI using
raw pthreads. Validates ABI compatibility: a standard
<code>gcc -fopenmp</code> test program links against our library and runs
correctly. This phase establishes the full API surface without GHC
involvement.</p>

<h3><span class="phase-label">Phase 2</span> GHC RTS Integration</h3>
<p>Replace the pthread thread pool with GHC Capabilities. Workers are created
via <code>pthread_create</code> but immediately pin themselves to Capabilities.
The RTS is booted on first use via <code>hs_init_ghc()</code>. A mutex+condvar
dispatch mechanism wakes workers for each parallel region.</p>

<div class="highlight">
<p><strong>Design decision</strong>: We chose a hybrid approach (Option D) &mdash;
a C shim calling GHC RTS APIs &mdash; over modifying GHC's RTS source directly
or using <code>foreign export</code>. This keeps the runtime as a single
<code>.c</code> file with no GHC fork required.</p>
</div>

<h3><span class="phase-label">Phase 3</span> Lock-free Optimization</h3>
<p>Phase 2 benchmarks showed 20-25x overhead on fork/join and 14x on barriers
versus native libgomp, all from mutex+condvar synchronization. Four
optimizations brought performance to parity:</p>

<table>
<tr><th>Optimization</th><th>Before</th><th>After</th><th>Improvement</th></tr>
<tr><td>Atomic generation counter (lock-free dispatch)</td><td colspan="3" rowspan="4" style="vertical-align:middle; text-align:center">
Fork/join: 24.35 &rarr; 0.81 us (<strong>30x</strong>)<br>
Barrier: 7.01 &rarr; 0.25 us (<strong>28x</strong>)
</td></tr>
<tr><td>Spin-wait with condvar fallback (4000 iters)</td></tr>
<tr><td>Sense-reversing centralized barriers</td></tr>
<tr><td>Atomic completion counter</td></tr>
</table>

<h3><span class="phase-label">Phase 4</span> Haskell FFI Interop</h3>
<p>A Haskell program calls OpenMP-parallelized C functions (dot product, SAXPY,
sin sum) via <code>foreign import ccall safe</code>. GHC releases the calling
Capability during the FFI call, allowing our runtime to use it. Verified
correctness against pure Haskell implementations and measured near-linear
scaling up to 8 threads.</p>

<h3><span class="phase-label">Phase 5</span> Concurrent Haskell + OpenMP</h3>
<p>Demonstrates that Haskell green threads and OpenMP parallel regions run
simultaneously on the same RTS. A pure Haskell computation runs in one
<code>forkIO</code> thread while an OpenMP FFI call runs in another. The safe
FFI call releases its Capability, so Haskell threads are not starved.</p>

<p>Result: sequential time 68ms &rarr; concurrent time 58ms (1.17x speedup),
with 10ms of verified overlap.</p>

<h3><span class="phase-label">Phase 6</span> GC Interaction Test</h3>
<p>Runs 500 short OpenMP parallel regions concurrently with either allocation
pressure (triggering minor GCs) or forced major GCs. Measures per-region
latency impact. Finding: GC has <strong>minimal impact</strong> on OpenMP tail
latency (worst p99: 1.17x, worst max: 3.27x on one run, none on another).</p>

<h3><span class="phase-label">Phase 7</span> Dense Matrix Multiply</h3>
<p>A real numerical workload: NxN dense matrix multiplication (DGEMM) with
OpenMP parallel for, called from Haskell. Tests sustained parallel computation
with large memory footprint. Results: 3-6x speedup over sequential Haskell at
4 threads across 128-1024 matrix sizes, all results verified correct.</p>

<h3><span class="phase-label">Phase 8</span> Head-to-Head Comparison</h3>
<p>The same DGEMM code compiled against native libgomp and our RTS-backed
runtime. Identical checksums, indistinguishable performance. Details in
<a href="#sec-dgemm">Section 10.2</a>.</p>

<h3><span class="phase-label">Phase 9</span> Bidirectional Interop</h3>
<p>OpenMP workers call back into Haskell via <code>FunPtr</code>. The
<code>foreign import ccall "wrapper"</code> stub automatically handles
Capability acquisition. All results verified correct; overhead is ~0.5us
per callback (the <code>rts_lock/rts_unlock</code> round-trip). Details in
<a href="#bidirectional">Section 9</a>.</p>

<!-- ================================================================ -->
<h2 id="optimization">6. Optimization: From 24x Slower to Parity</h2>

<p>The Phase 2 runtime was functional but slow: fork/join took 24 us vs
libgomp's 1 us. The bottleneck was mutex+condvar on every operation. We
eliminated all locks from the hot path:</p>

<h3>6.1 Lock-free Work Dispatch</h3>
<pre><code>// Master: store work, then release-fence generation increment
g_pool.fn = fn;
g_pool.data = data;
atomic_fetch_add(&amp;g_pool.generation, 1, memory_order_release);

// Worker: spin on generation (acquire-fence)
while (atomic_load(&amp;g_pool.generation, memory_order_acquire) == my_gen)
    _mm_pause();</code></pre>

<p>No mutex on the hot path. The condvar broadcast is only for workers that
fell asleep after 4000 spin iterations.</p>

<h3>6.2 Sense-Reversing Barrier</h3>
<pre><code>void spin_barrier_wait(spin_barrier_t *b, int *local_sense) {
    *local_sense = 1 - *local_sense;
    if (atomic_fetch_sub(&amp;b->count, 1, memory_order_acq_rel) == 1) {
        // Last thread: reset counter, flip global sense
        atomic_store(&amp;b->count, b->size, memory_order_relaxed);
        atomic_store(&amp;b->sense, *local_sense, memory_order_release);
    } else {
        // Spin until sense matches
        while (atomic_load(&amp;b->sense, memory_order_acquire) != *local_sense)
            _mm_pause();
    }
}</code></pre>

<p>Pure atomic operations, no locks. The centralized design has O(N) wakeup but
is optimal for small team sizes (typical OpenMP use).</p>

<h3>6.3 Results</h3>

<table>
<tr><th>Metric (4 threads)</th><th>Phase 2</th><th>Phase 3</th><th>Native libgomp</th></tr>
<tr><td>Fork/join</td><td class="num">24.35 us</td><td class="num">0.81 us</td><td class="num">0.97 us</td></tr>
<tr><td>Barrier</td><td class="num">7.01 us</td><td class="num">0.25 us</td><td class="num">0.51 us</td></tr>
<tr><td>Parallel for (1M sin)</td><td class="num">6.71 ms</td><td class="num">3.91 ms</td><td class="num">3.85 ms</td></tr>
<tr><td>Critical section</td><td class="num">0.39 ms</td><td class="num">0.38 ms</td><td class="num">0.92 ms</td></tr>
</table>

<p>After optimization, the RTS-backed runtime <strong>matches or beats</strong>
native libgomp on all benchmarks.</p>

<!-- ================================================================ -->
<h2 id="haskell-interop">7. Haskell Interop</h2>

<h3>7.1 FFI Calling Convention</h3>

<p>Haskell calls OpenMP C code via <code>foreign import ccall safe</code>:</p>

<pre><code>foreign import ccall safe "parallel_sinsum"
    c_parallel_sinsum :: CInt -> IO CDouble</code></pre>

<p>The <code>safe</code> keyword is critical: it tells GHC to release the
calling Capability before entering the foreign code, and reacquire it on
return. This means:</p>

<ul>
  <li>Other Haskell green threads can run on the released Capability</li>
  <li>The C code enters <code>GOMP_parallel</code>, which dispatches to the
  worker pool &mdash; including potentially the Capability just released</li>
  <li>No deadlock: workers don't need to hold Capabilities to execute C
  compute kernels</li>
</ul>

<h3>7.2 RTS Initialization: Reference Counting</h3>

<p>When called from a Haskell host, <code>hs_init_ghc()</code> is already done
by GHC before <code>main</code>. Our runtime's <code>ensure_rts()</code> calls
<code>hs_init_ghc()</code> again, which simply increments the reference count
and returns. The runtime discovers the existing Capabilities via
<code>getNumCapabilities()</code> and spawns workers for Caps 1..N-1.</p>

<h3>7.3 Concurrent Execution</h3>

<pre><code>-- Haskell green thread: pure computation
_ &lt;- forkIO $ do
    let !result = haskellSinSum 1200000
    putMVar hsDone result

-- OpenMP FFI call (safe: releases Capability)
_ &lt;- forkIO $ do
    result &lt;- c_parallel_sinsum 12000000
    putMVar ompDone result

-- Both run simultaneously!</code></pre>

<p>Measured: sequential 68ms &rarr; concurrent 58ms, with 10ms of overlapping
execution confirmed.</p>

<!-- ================================================================ -->
<h2 id="gc-interaction">8. Garbage Collection Interaction</h2>

<p>A key concern: GHC's stop-the-world GC pauses all threads holding
Capabilities. Would this stall OpenMP workers?</p>

<div class="highlight">
<p><strong>Answer: No.</strong> OpenMP workers do not hold Capabilities during
parallel execution. After their initial
<code>rts_lock()/rts_unlock()</code> registration, they are plain OS threads
spinning on atomic variables. GC only synchronizes Capability-holding threads
&mdash; our workers are invisible.</p>
</div>

<h3>8.1 Experimental Validation</h3>

<p>We ran 500 OpenMP parallel regions (each ~400us) concurrently with:</p>

<table>
<tr><th>Scenario</th><th>p50 (us)</th><th>p99 (us)</th><th>max (us)</th></tr>
<tr><td>Baseline (OpenMP alone)</td><td class="num">314&ndash;478</td><td class="num">636&ndash;658</td><td class="num">692&ndash;783</td></tr>
<tr><td>+ allocation pressure (50K rounds)</td><td class="num">313&ndash;543</td><td class="num">538&ndash;651</td><td class="num">585&ndash;691</td></tr>
<tr><td>+ forced major GC (20 &times; performGC)</td><td class="num">315&ndash;556</td><td class="num">549&ndash;744</td><td class="num">574&ndash;2262</td></tr>
</table>

<p>Allocation pressure has negligible impact (within noise). Forced major GCs
produced one outlier spike of 2262us on one run and none on another. The spike
correlates with the GHC RTS reporting a 1.6ms max GC pause &mdash; likely the
OS thread making the FFI call had its Capability briefly paused at a region
boundary.</p>

<p>GHC RTS statistics: 99.7% productivity, GC time &lt;0.5% of elapsed.</p>

<!-- ================================================================ -->
<h2 id="bidirectional">9. Bidirectional Interop</h2>

<p>Phases 4&ndash;7 demonstrated Haskell calling OpenMP. Phase 9 completes the
picture: <strong>OpenMP workers calling back into Haskell</strong> from within
a parallel region.</p>

<h3>9.1 Mechanism</h3>

<p>Haskell creates a <code>FunPtr</code> via
<code>foreign import ccall "wrapper"</code>:</p>

<pre><code>foreign import ccall "wrapper"
    mkCallback :: (CInt -> IO CDouble)
               -> IO (FunPtr (CInt -> IO CDouble))

sinCb &lt;- mkCallback (\i -> return (sin (fromIntegral i * 0.001)))</code></pre>

<p>GHC generates a C stub that wraps the Haskell closure with automatic
Capability management:</p>

<pre><code>// Generated wrapper (simplified):
CDouble wrapper(CInt arg) {
    Capability *cap = rts_lock();      // acquire Capability
    // ... evaluate Haskell closure ...
    rts_unlock(cap);                   // release Capability
    return result;
}</code></pre>

<p>The C code calls this <code>FunPtr</code> from inside an OpenMP parallel for:</p>

<pre><code>void parallel_reduce_callback(hs_callback_t callback, int n) {
    double sum = 0.0;
    #pragma omp parallel for reduction(+:sum) schedule(static)
    for (int i = 0; i &lt; n; i++)
        sum += callback(i);  // each worker calls into Haskell
    return sum;
}</code></pre>

<h3>9.2 Correctness</h3>

<p>All results verified against pure C and pure Haskell reference
implementations:</p>

<table>
<tr><th>Test</th><th>Result</th><th>Status</th></tr>
<tr><td>parallel_map (1000 sin values)</td><td>Element-wise match to 1e-10</td><td><span class="badge badge-ok">OK</span></td></tr>
<tr><td>parallel_reduce (100K sin sum)</td><td>1839.343386 (matches pure C)</td><td><span class="badge badge-ok">OK</span></td></tr>
<tr><td>polynomial callback (10K)</td><td>1109840.005000 (matches Haskell)</td><td><span class="badge badge-ok">OK</span></td></tr>
</table>

<h3>9.3 Performance</h3>

<table>
<tr><th>Threads</th><th>Pure C (ms)</th><th>Callback (ms)</th><th>Overhead</th><th>Per-callback</th></tr>
<tr><td>1</td><td class="num">1.69</td><td class="num">46.60</td><td class="num">27.6x</td><td class="num">~0.47 us</td></tr>
<tr><td>2</td><td class="num">1.17</td><td class="num">60.43</td><td class="num">51.8x</td><td class="num">~0.60 us</td></tr>
<tr><td>4</td><td class="num">0.71</td><td class="num">57.91</td><td class="num">82.1x</td><td class="num">~0.58 us</td></tr>
</table>

<p>The per-callback cost of ~0.5us is the <code>rts_lock()/rts_unlock()</code>
round-trip. This is constant regardless of what the Haskell function does.
For callbacks that perform milliseconds of work (e.g., looking up a Haskell
data structure, evaluating a complex expression), the overhead is negligible.
For tight inner loops like 100K trivial sin() calls, pure C should be used
instead.</p>

<div class="highlight">
<p><strong>Practical guideline</strong>: Use Haskell callbacks when each
invocation does &ge;100us of work. Below that, the
<code>rts_lock/unlock</code> overhead dominates. Structure code so that
OpenMP handles the hot numerical loop in C, and calls Haskell for complex
logic at coarser granularity.</p>
</div>

<!-- ================================================================ -->
<h2 id="benchmarks">10. Benchmarks</h2>
<!-- section renumbered -->

<p>All benchmarks on an Intel i7-10750H (6C/12T), NixOS, GCC 15.2, GHC 9.10.3,
powersave governor. Best-of-N timing to reduce CPU frequency variance.</p>

<h3>10.1 Microbenchmarks (Phase 3)</h3>

<h4>Fork/Join Overhead (us/iter)</h4>
<table>
<tr><th>Threads</th><th>Native libgomp</th><th>RTS-backed</th><th>Ratio</th></tr>
<tr><td>1</td><td class="num">0.171</td><td class="num">0.030</td><td><span class="badge badge-fast">5.7x faster</span></td></tr>
<tr><td>2</td><td class="num">0.828</td><td class="num">0.420</td><td><span class="badge badge-fast">2.0x faster</span></td></tr>
<tr><td>4</td><td class="num">0.972</td><td class="num">0.811</td><td><span class="badge badge-fast">1.2x faster</span></td></tr>
<tr><td>8</td><td class="num">1.346</td><td class="num">1.517</td><td><span class="badge badge-ok">1.13x</span></td></tr>
</table>

<h4>Barrier Latency (us/iter)</h4>
<table>
<tr><th>Threads</th><th>Native libgomp</th><th>RTS-backed</th><th>Ratio</th></tr>
<tr><td>1</td><td class="num">0.026</td><td class="num">0.002</td><td><span class="badge badge-fast">13x faster</span></td></tr>
<tr><td>2</td><td class="num">0.313</td><td class="num">0.136</td><td><span class="badge badge-fast">2.3x faster</span></td></tr>
<tr><td>4</td><td class="num">0.508</td><td class="num">0.254</td><td><span class="badge badge-fast">2.0x faster</span></td></tr>
<tr><td>8</td><td class="num">0.762</td><td class="num">0.482</td><td><span class="badge badge-fast">1.6x faster</span></td></tr>
</table>

<h4>Parallel For + Reduction (1M sin(), best of 10, ms)</h4>
<table>
<tr><th>Threads</th><th>Native libgomp</th><th>RTS-backed</th><th>Ratio</th></tr>
<tr><td>1</td><td class="num">15.764</td><td class="num">15.427</td><td><span class="badge badge-ok">0.98x</span></td></tr>
<tr><td>2</td><td class="num">7.730</td><td class="num">7.783</td><td><span class="badge badge-ok">1.01x</span></td></tr>
<tr><td>4</td><td class="num">3.849</td><td class="num">3.905</td><td><span class="badge badge-ok">1.01x</span></td></tr>
<tr><td>8</td><td class="num">3.358</td><td class="num">3.503</td><td><span class="badge badge-ok">1.04x</span></td></tr>
</table>

<h4>Critical Section (1000 lock/unlock per thread, ms)</h4>
<table>
<tr><th>Threads</th><th>Native libgomp</th><th>RTS-backed</th><th>Ratio</th></tr>
<tr><td>1</td><td class="num">0.054</td><td class="num">0.026</td><td><span class="badge badge-fast">2.1x faster</span></td></tr>
<tr><td>2</td><td class="num">0.318</td><td class="num">0.254</td><td><span class="badge badge-fast">1.3x faster</span></td></tr>
<tr><td>4</td><td class="num">0.915</td><td class="num">0.381</td><td><span class="badge badge-fast">2.4x faster</span></td></tr>
<tr><td>8</td><td class="num">2.135</td><td class="num">1.201</td><td><span class="badge badge-fast">1.8x faster</span></td></tr>
</table>

<h3 id="sec-dgemm">10.2 DGEMM Head-to-Head (Phase 8)</h3>

<p>Same naive triple-loop DGEMM compiled identically, linked against either
native libgomp or our runtime. Checksums match exactly.</p>

<h4>4 Threads</h4>
<table>
<tr><th>N</th><th>Native (ms)</th><th>RTS (ms)</th><th>Ratio</th><th>GFLOPS (RTS)</th></tr>
<tr><td>128</td><td class="num">0.86</td><td class="num">0.94</td><td><span class="badge badge-ok">1.09x</span></td><td class="num">4.44</td></tr>
<tr><td>256</td><td class="num">12.62</td><td class="num">12.28</td><td><span class="badge badge-ok">0.97x</span></td><td class="num">2.73</td></tr>
<tr><td>512</td><td class="num">77.51</td><td class="num">76.96</td><td><span class="badge badge-ok">0.99x</span></td><td class="num">3.49</td></tr>
<tr><td>1024</td><td class="num">748.83</td><td class="num">663.37</td><td><span class="badge badge-fast">0.89x</span></td><td class="num">3.24</td></tr>
</table>

<p>Interleaved re-runs confirm the two runtimes trade leads: the difference is
CPU frequency noise, not runtime overhead.</p>

<h4>Scaling (RTS-backed, DGEMM 1024x1024)</h4>
<table>
<tr><th>Threads</th><th>Time (ms)</th><th>GFLOPS</th><th>Speedup</th></tr>
<tr><td>1</td><td class="num">2434.99</td><td class="num">0.88</td><td class="num">1.0x</td></tr>
<tr><td>2</td><td class="num">1330.19</td><td class="num">1.61</td><td class="num">1.8x</td></tr>
<tr><td>4</td><td class="num">663.37</td><td class="num">3.24</td><td class="num">3.7x</td></tr>
</table>

<h3>10.3 Haskell FFI Scaling (Phase 4, parallel sinsum)</h3>

<table>
<tr><th>Threads</th><th>Time (ms)</th><th>Speedup</th></tr>
<tr><td>1</td><td class="num">32.5</td><td class="num">1.0x</td></tr>
<tr><td>2</td><td class="num">17.3</td><td class="num">1.9x</td></tr>
<tr><td>4</td><td class="num">9.9</td><td class="num">3.3x</td></tr>
<tr><td>8</td><td class="num">5.0</td><td class="num">6.5x</td></tr>
</table>

<p>Near-linear scaling through the FFI boundary, confirming the runtime
correctly parallelizes work dispatched from Haskell.</p>

<!-- ================================================================ -->
<h2 id="bugs">11. Notable Bugs and Fixes</h2>

<h3>11.1 Barrier Sense Mismatch Deadlock</h3>

<p><strong>Symptom</strong>: Program hangs when calling <code>GOMP_parallel</code>
from a <code>forkIO</code> thread at <code>-N4</code>. No output at all. Works
at <code>-N1</code>.</p>

<p><strong>Root cause</strong>: Workers' local barrier sense variables
(<code>start_sense</code>, <code>end_sense</code>) persisted from previous
parallel regions (value 1), but <code>spin_barrier_init()</code> reset the
barrier's global sense to 0. On the next region:</p>

<ul>
  <li>Workers flipped 1&rarr;0, saw <code>sense(0) == local_sense(0)</code>, passed through immediately</li>
  <li>Master (on a new OS thread from <code>forkIO</code>) had fresh sense=0, flipped to 1, but couldn't complete the barrier</li>
</ul>

<p><strong>Fix</strong>: Reset all local sense variables to 0 at the start of
each parallel region, matching the freshly initialized barriers.</p>

<h3>11.2 False Parallel-For Regression</h3>

<p><strong>Symptom</strong>: At 4 threads, parallel for appeared 1.65x slower
than native libgomp (6.7ms vs 4.1ms).</p>

<p><strong>Root cause</strong>: Single-sample measurement on a laptop with
<code>powersave</code> CPU governor (i7-10750H at 46% clock). CPU boost state
varied between process invocations.</p>

<p><strong>Fix</strong>: Changed to best-of-10 within each process. Controlled
interleaved testing confirmed parity (3.85ms vs 3.91ms).</p>

<!-- ================================================================ -->
<h2 id="limitations">12. Limitations</h2>

<table>
<tr><th>Limitation</th><th>Impact</th><th>Notes</th></tr>
<tr><td>No nested parallelism</td><td>Low</td><td>Inner parallel regions run with 1 thread. <code>setNumCapabilities</code> only increases.</td></tr>
<tr><td>Tasks execute inline</td><td>Medium</td><td><code>GOMP_task</code> runs the task immediately (no deferred execution, no work stealing). Sufficient for <code>#pragma omp task</code> correctness but not for performance.</td></tr>
<tr><td>Single global team</td><td>Low</td><td>No support for different thread counts in nested teams.</td></tr>
<tr><td>No target offloading</td><td>None</td><td>Not applicable to this project's scope.</td></tr>
<tr><td>No doacross loops</td><td>Low</td><td><code>GOMP_doacross_*</code> not implemented.</td></tr>
<tr><td>Guided schedule = dynamic</td><td>Low</td><td>Our guided schedule uses the same algorithm as dynamic (constant chunk size).</td></tr>
</table>

<!-- ================================================================ -->
<h2 id="conclusions">13. Conclusions</h2>

<p>GHC's Runtime System can serve as a fully functional OpenMP runtime with
<strong>zero measurable overhead</strong> compared to native libgomp. The
implementation is a single 800-line C file using only public GHC RTS APIs &mdash;
no GHC fork required.</p>

<p>The key architectural insights are:</p>

<ol>
  <li><strong>Capabilities as thread IDs</strong>: <code>cap-&gt;no</code>
  directly maps to <code>omp_get_thread_num()</code></li>
  <li><strong>Workers without Capabilities</strong>: After RTS registration,
  worker threads release their Capabilities. They execute C code as plain OS
  threads, invisible to GC.</li>
  <li><strong>Reference-counted init</strong>: <code>hs_init_ghc()</code>
  is idempotent, enabling transparent use from both C and Haskell hosts.</li>
  <li><strong>Lock-free synchronization is essential</strong>: The naive
  mutex+condvar implementation was 20-25x slower. Sense-reversing barriers
  and atomic generation counters brought it to parity.</li>
  <li><strong>Bidirectional FFI works</strong>: OpenMP workers call Haskell
  functions via <code>FunPtr</code> with ~0.5us overhead per invocation
  (automatic <code>rts_lock/unlock</code>), making it practical for
  coarse-grained callbacks.</li>
</ol>

<p>This demonstrates that language runtimes can share threading infrastructure
across FFI boundaries. A Haskell program can call OpenMP C code, with both
sharing the same thread pool, the same CPU cores, and coexisting with GHC's
garbage collector.</p>

<!-- ================================================================ -->
<h2 id="appendix">Appendix: Implemented ABI Surface</h2>

<h4>Core Parallel</h4>
<p><code>GOMP_parallel</code>,
<code>GOMP_parallel_start</code>,
<code>GOMP_parallel_end</code>,
<code>GOMP_barrier</code></p>

<h4>Synchronization</h4>
<p><code>GOMP_critical_start</code>,
<code>GOMP_critical_end</code>,
<code>GOMP_critical_name_start</code>,
<code>GOMP_critical_name_end</code>,
<code>GOMP_atomic_start</code>,
<code>GOMP_atomic_end</code>,
<code>GOMP_single_start</code>,
<code>GOMP_single_copy_start</code>,
<code>GOMP_single_copy_end</code>,
<code>GOMP_ordered_start</code>,
<code>GOMP_ordered_end</code></p>

<h4>Worksharing Loops</h4>
<p><code>GOMP_loop_static_start</code>,
<code>GOMP_loop_static_next</code>,
<code>GOMP_loop_dynamic_start</code>,
<code>GOMP_loop_dynamic_next</code>,
<code>GOMP_loop_guided_start</code>,
<code>GOMP_loop_guided_next</code>,
<code>GOMP_loop_runtime_start</code>,
<code>GOMP_loop_runtime_next</code>,
<code>GOMP_loop_start</code>,
<code>GOMP_loop_end</code>,
<code>GOMP_loop_end_nowait</code>,
<code>GOMP_parallel_loop_static</code>,
<code>GOMP_parallel_loop_dynamic</code>,
<code>GOMP_parallel_loop_guided</code>,
<code>GOMP_parallel_loop_runtime</code></p>

<h4>Tasks</h4>
<p><code>GOMP_task</code>,
<code>GOMP_taskwait</code>,
<code>GOMP_taskyield</code>,
<code>GOMP_taskgroup_start</code>,
<code>GOMP_taskgroup_end</code></p>

<h4>Sections</h4>
<p><code>GOMP_sections_start</code>,
<code>GOMP_sections_next</code>,
<code>GOMP_sections_end</code>,
<code>GOMP_sections_end_nowait</code>,
<code>GOMP_parallel_sections</code></p>

<h4>Cancellation &amp; Teams</h4>
<p><code>GOMP_cancel</code>,
<code>GOMP_cancellation_point</code>,
<code>GOMP_barrier_cancel</code>,
<code>GOMP_loop_end_cancel</code>,
<code>GOMP_sections_end_cancel</code>,
<code>GOMP_teams_reg</code></p>

<h4>omp_* User API</h4>
<p><code>omp_get_num_threads</code>,
<code>omp_get_thread_num</code>,
<code>omp_get_max_threads</code>,
<code>omp_get_num_procs</code>,
<code>omp_set_num_threads</code>,
<code>omp_in_parallel</code>,
<code>omp_set_dynamic</code>,
<code>omp_get_dynamic</code>,
<code>omp_set_nested</code>,
<code>omp_get_nested</code>,
<code>omp_get_wtime</code>,
<code>omp_get_wtick</code>,
<code>omp_init_lock</code>,
<code>omp_destroy_lock</code>,
<code>omp_set_lock</code>,
<code>omp_unset_lock</code>,
<code>omp_test_lock</code>,
<code>omp_init_nest_lock</code>,
<code>omp_destroy_nest_lock</code>,
<code>omp_set_nest_lock</code>,
<code>omp_unset_nest_lock</code>,
<code>omp_test_nest_lock</code>,
<code>omp_get_level</code>,
<code>omp_get_active_level</code>,
<code>omp_get_ancestor_thread_num</code>,
<code>omp_get_team_size</code>,
<code>omp_get_thread_limit</code>,
<code>omp_set_max_active_levels</code>,
<code>omp_get_max_active_levels</code>,
<code>omp_get_supported_active_levels</code>,
<code>omp_set_schedule</code>,
<code>omp_get_schedule</code>,
<code>omp_in_final</code>,
<code>omp_get_cancellation</code>,
<code>omp_get_proc_bind</code>,
<code>omp_get_num_places</code>,
<code>omp_get_place_num</code>,
<code>omp_get_default_device</code>,
<code>omp_set_default_device</code>,
<code>omp_get_num_devices</code>,
<code>omp_get_num_teams</code>,
<code>omp_get_team_num</code>,
<code>omp_is_initial_device</code>,
<code>omp_get_initial_device</code>,
<code>omp_get_max_task_priority</code></p>

<hr>

<footer>
<p>Environment: NixOS, GHC 9.10.3, GCC 15.2.0, Intel i7-10750H (6C/12T).<br>
Source code: <code>ghc-openmp</code> repository. February 2026.</p>
</footer>

</body>
</html>
