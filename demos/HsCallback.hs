{- |
   Phase 9: Bidirectional interop — OpenMP workers call Haskell callbacks.

   Demonstrates that OpenMP worker threads can call back into Haskell
   from within a parallel region. The FunPtr wrapper (generated by
   "foreign import ccall wrapper") automatically acquires a GHC
   Capability via rts_lock() before executing the Haskell closure.

   Run: ./callback_demo +RTS -N4
-}
module Main where

import Control.Monad (forM_)
import Foreign
import Foreign.C
import GHC.Clock (getMonotonicTimeNSec)
import Text.Printf

-- FFI imports
foreign import ccall safe "parallel_map_callback"
    c_parallel_map_callback :: FunPtr (CInt -> IO CDouble)
                            -> Ptr CDouble -> CInt -> IO ()

foreign import ccall safe "parallel_reduce_callback"
    c_parallel_reduce_callback :: FunPtr (CInt -> IO CDouble)
                               -> CInt -> IO CDouble

foreign import ccall safe "parallel_sinsum"
    c_parallel_sinsum :: CInt -> IO CDouble

foreign import ccall safe "get_omp_num_threads"
    c_get_omp_num_threads :: IO CInt

-- Create FunPtr from Haskell closure.
-- The generated wrapper stub does rts_lock()/rts_unlock() automatically.
foreign import ccall "wrapper"
    mkCallback :: (CInt -> IO CDouble) -> IO (FunPtr (CInt -> IO CDouble))

-- | Wall clock time in milliseconds
nowMs :: IO Double
nowMs = do
    ns <- getMonotonicTimeNSec
    return (fromIntegral ns / 1e6)

-- | A Haskell function to be called from OpenMP threads: sin(i * 0.001)
hsSin :: CInt -> IO CDouble
hsSin i = return (CDouble (sin (fromIntegral i * 0.001)))

-- | A more complex Haskell callback: polynomial evaluation
hsPoly :: CInt -> IO CDouble
hsPoly i = do
    let x = fromIntegral i * 0.001 :: Double
    return (CDouble (3.0 * x * x + 2.0 * x + 1.0))

main :: IO ()
main = do
    putStrLn "=== Phase 9: Bidirectional Interop ==="
    putStrLn "    OpenMP workers calling Haskell callbacks"
    putStrLn ""

    nthreads <- c_get_omp_num_threads
    printf "OpenMP threads: %d\n" (fromIntegral nthreads :: Int)
    putStrLn ""

    -- Test 1: Correctness — parallel map with Haskell sin callback
    putStrLn "--- Test 1: Parallel map with Haskell callback ---"
    sinCb <- mkCallback hsSin
    let n1 = 1000
    allocaArray n1 $ \pOut -> do
        c_parallel_map_callback sinCb pOut (fromIntegral n1)
        -- Verify first and last elements
        v0 <- peekElemOff pOut 0
        v999 <- peekElemOff pOut 999
        let expected0 = sin (0.0 * 0.001) :: Double
            expected999 = sin (999.0 * 0.001) :: Double
        printf "  out[0]   = %.6f (expected %.6f) %s\n"
            (realToFrac v0 :: Double) expected0
            (if abs (realToFrac v0 - expected0) < 1e-10 then "OK" else "MISMATCH" :: String)
        printf "  out[999] = %.6f (expected %.6f) %s\n"
            (realToFrac v999 :: Double) expected999
            (if abs (realToFrac v999 - expected999) < 1e-10 then "OK" else "MISMATCH" :: String)
    putStrLn ""

    -- Test 2: Correctness — parallel reduce with Haskell callback
    putStrLn "--- Test 2: Parallel reduce with Haskell callback ---"
    let n2 = 10000
    result <- c_parallel_reduce_callback sinCb (fromIntegral n2)
    -- Compare against pure C OpenMP sinsum (same computation)
    cResult <- c_parallel_sinsum (fromIntegral n2)
    let diff = abs (realToFrac result - realToFrac cResult :: Double)
    printf "  Haskell callback reduce: %.6f\n" (realToFrac result :: Double)
    printf "  Pure C OpenMP sinsum:    %.6f\n" (realToFrac cResult :: Double)
    printf "  Difference: %.2e %s\n" diff
        (if diff < 1e-6 then "OK" else "MISMATCH" :: String)
    putStrLn ""

    -- Test 3: Performance — compare callback vs pure C
    putStrLn "--- Test 3: Performance comparison ---"
    let n3 = 100000

    -- Pure C OpenMP (no callback overhead)
    _ <- c_parallel_sinsum (fromIntegral n3)  -- warmup
    t0 <- nowMs
    forM_ [1..10 :: Int] $ \_ ->
        c_parallel_sinsum (fromIntegral n3)
    t1 <- nowMs
    let cMs = (t1 - t0) / 10.0

    -- Haskell callback via OpenMP
    _ <- c_parallel_reduce_callback sinCb (fromIntegral n3)  -- warmup
    t2 <- nowMs
    forM_ [1..10 :: Int] $ \_ ->
        c_parallel_reduce_callback sinCb (fromIntegral n3)
    t3 <- nowMs
    let cbMs = (t3 - t2) / 10.0

    printf "  Pure C OpenMP (100K sin):     %6.2f ms\n" cMs
    printf "  Haskell callback (100K sin):  %6.2f ms\n" cbMs
    printf "  Callback overhead: %.1fx\n" (cbMs / cMs)
    putStrLn ""

    -- Test 4: Complex callback — polynomial evaluation
    putStrLn "--- Test 4: Complex Haskell callback (polynomial) ---"
    polyCb <- mkCallback hsPoly
    let n4 = 10000
    polyResult <- c_parallel_reduce_callback polyCb (fromIntegral n4)
    -- Verify against direct Haskell computation
    let hsPolySum = sum [ 3.0 * x * x + 2.0 * x + 1.0
                        | i <- [0..n4-1]
                        , let x = fromIntegral i * 0.001 :: Double ]
    let polyDiff = abs (realToFrac polyResult - hsPolySum)
    printf "  OpenMP+Haskell reduce: %.6f\n" (realToFrac polyResult :: Double)
    printf "  Pure Haskell sum:      %.6f\n" hsPolySum
    printf "  Difference: %.2e %s\n" polyDiff
        (if polyDiff < 1e-4 then "OK" else "MISMATCH" :: String)
    putStrLn ""

    -- Cleanup
    freeHaskellFunPtr sinCb
    freeHaskellFunPtr polyCb

    -- Summary
    putStrLn "--- Summary ---"
    putStrLn "  OpenMP workers successfully call Haskell functions"
    putStrLn "  via FunPtr with automatic Capability acquisition."
    printf  "  Callback overhead: %.1fx vs pure C\n" (cbMs / cMs)
    putStrLn "  (rts_lock/rts_unlock per invocation)"
    putStrLn ""
    putStrLn "=== Done ==="
